<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<title>IIIA uzd. ND</title>
		<style>
			body { margin: 0; }
		</style>
        <!-- <script src="lib/three.js"></script> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js" integrity="sha512-u+vtyZDzyd0zgAEffKfoNx2BnCahAOBBYvzGu6vma1B18zQ6lEGF3F6dAFvqaxDoIU/GZRxcXV5oq23OIrkQwg==" crossorigin="anonymous"></script>
       
    </head>
    <body>
        <canvas id="c"></canvas>
        <script type="module">
            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.module.js';
            import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
            import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";
            import { LineGeometry } from "https://threejs.org/examples/jsm/lines/LineGeometry.js";
            import { LineMaterial } from "https://threejs.org/examples/jsm/lines/LineMaterial.js";
            import { Line2 } from "https://threejs.org/examples/jsm/lines/Line2.js";
            function main() {
                // NOTE:
                // Fix arrow height
                const canvas = document.querySelector('#c');
                const renderer = new THREE.WebGLRenderer({canvas});
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // Creating camera
                const fov = 80;
                const aspect =  2;  // the canvas default
                const near = 0.1;
                const far = 1000;
                const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.z = 15;

                // Setuping orbit controls
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render );
                
                // Adding 3D grid
                const size = 10;
                const divisions = 10;

                const gridHelper = new THREE.GridHelper( size, divisions );
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.add( gridHelper );

                //Adding 3d axes
                const axesHelper = new THREE.AxesHelper( 10 );
                scene.add( axesHelper );
                // Adding basic light
                {
                    const color = 0xFFFFFF;
                    const intensity = 2;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 5, 15);
                    scene.add(light);

                    const color1 = 0xFFFFFF;
                    const intensity1 = 2;
                    const light1 = new THREE.DirectionalLight(color1, intensity1);
                    light1.position.set(0, -5, -15);
                    scene.add(light1);
                }
            

                // const curve = new THREE.EllipseCurve(
                //     0,  0,            // ax, aY
                //     10, 10,           // xRadius, yRadius
                //     0,  2 * Math.PI,  // aStartAngle, aEndAngle
                //     false,            // aClockwise
                //     0                 // aRotation
                // );

                // const points = curve.getPoints( 50 );
                // console.log(points);
                // const geometry = new THREE.BufferGeometry().setFromPoints( points );

                // const material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

                // // Create the final object to add to the scene
                // const ellipse = new THREE.Line( geometry, material );

            //    var height = 10;
            
                var r = 5;
               
                var points = [];
           
               for(let i = 0; i <= 360; i++){
                    var x = Math.sin(i*Math.PI/180) * r;
                    var z = Math.cos(i*Math.PI/180) * r;
                    // var x = getRandomInt(-r, r);
                    // var z = getRandomInt(-r, r);
                    if (x*x + z*z - r*r < 0)
                        points.push(new THREE.Vector3(x, 0, z));
                }

                for(let i = 0; i <= 360; i++){
                    var x = Math.sin(i * Math.PI/180) * r/2;
                    var z = Math.cos(i * Math.PI/180) * r/2;
                    // var x = getRandomInt(-r, r);
                    // var z = getRandomInt(-r, r);
                    if (x*x + z*z - r*r < 0)
                        points.push(new THREE.Vector3(x, 5, z));
                }
                const bufferGeometry = new ConvexGeometry( points );
                var geometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );
               

                const loader = new THREE.TextureLoader();
                const texture = loader.load('resources/images/checker.jpg');
                texture.repeat.set(0.5, 0.5);
                texture.wrapS = texture.wrapT = THREE.MirroredRepeatWrapping;
                var material = new THREE.MeshBasicMaterial( { 
                    map: texture,
                    side: THREE.DoubleSide
                } );
                assignUVs(geometry);
               
                const mesh = new THREE.Mesh( geometry, material );
                mesh.updateWorldMatrix(true);
                scene.add( mesh );
                
                function assignUVs(geometry) {
                    geometry.faceVertexUvs[0] = [];

                    geometry.faces.forEach(function(face) {

                        var uvs = [];
                        var ids = [ 'a', 'b', 'c'];
                        for( var i = 0; i < ids.length; i++ ) {
                            var vertex = geometry.vertices[ face[ ids[ i ] ] ].clone();

                            var n = vertex.normalize();
                            var yaw = .5 - Math.atan( n.z, - n.x ) / ( 2.0 * Math.PI );
                            var pitch = .5 - Math.asin( n.y ) / Math.PI;

                            var u = yaw,
                                v = pitch;
                            uvs.push( new THREE.Vector2( u, v ) );
                        }
                        geometry.faceVertexUvs[ 0 ].push( uvs );
                    });

                    geometry.uvsNeedUpdate = true;
            }
               //points.push(new THREE.Vector3(0, height, 0));

                
               // const material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
               
            

                function render()
                {
                    setTimeout( function() {
                         requestAnimationFrame(render);
                    }, 1000 / 30 ); //Pagreita kadru atvaizdavima
                    renderer.render( scene, camera );
                }

                render();
            }
            main();
        </script>
    </body>
</html>
