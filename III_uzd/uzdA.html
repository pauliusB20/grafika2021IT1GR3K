<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<title>IIIA uzd. ND</title>
		<style>
			body { margin: 0; }
		</style>
        <!-- <script src="lib/three.js"></script> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js" integrity="sha512-u+vtyZDzyd0zgAEffKfoNx2BnCahAOBBYvzGu6vma1B18zQ6lEGF3F6dAFvqaxDoIU/GZRxcXV5oq23OIrkQwg==" crossorigin="anonymous"></script>
       
    </head>
    <body>
        <canvas id="c"></canvas>
        <script type="module">
            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.module.js';
            import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
            import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";
            import { LineGeometry } from "https://threejs.org/examples/jsm/lines/LineGeometry.js";
            import { LineMaterial } from "https://threejs.org/examples/jsm/lines/LineMaterial.js";
            import { Line2 } from "https://threejs.org/examples/jsm/lines/Line2.js";
            function main() {
                // NOTE:
                // Fix arrow height
                const canvas = document.querySelector('#c');
                const renderer = new THREE.WebGLRenderer({canvas});
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // Creating camera
                const fov = 80;
                const aspect =  2;  // the canvas default
                const near = 0.1;
                const far = 1000;
                const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.z = 15;

                // Setuping orbit controls
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render );
                
                // Adding 3D grid
                const size = 10;
                const divisions = 10;

                const gridHelper = new THREE.GridHelper( size, divisions );
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.add( gridHelper );

                //Adding 3d axes
                const axesHelper = new THREE.AxesHelper( 10 );
                scene.add( axesHelper );
                // Adding basic light
                {
                    const color = 0xFFFFFF;
                    const intensity = 2;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 5, 15);
                    scene.add(light);

                    const color1 = 0xFFFFFF;
                    const intensity1 = 2;
                    const light1 = new THREE.DirectionalLight(color1, intensity1);
                    light1.position.set(0, -5, -15);
                    scene.add(light1);
                }
            

                // const curve = new THREE.EllipseCurve(
                //     0,  0,            // ax, aY
                //     10, 10,           // xRadius, yRadius
                //     0,  2 * Math.PI,  // aStartAngle, aEndAngle
                //     false,            // aClockwise
                //     0                 // aRotation
                // );

                // const points = curve.getPoints( 50 );
                // console.log(points);
                // const geometry = new THREE.BufferGeometry().setFromPoints( points );

                // const material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

                // // Create the final object to add to the scene
                // const ellipse = new THREE.Line( geometry, material );

            //    var height = 10;
                var r = 5;
               
                var points = [];
           
               for(let i = 0; i <= 360; i++){
                    points.push(new THREE.Vector3(Math.sin(i*Math.PI/180) * r, 0, Math.cos(i*Math.PI/180)*r));
                }
      
                
               //points.push(new THREE.Vector3(0, height, 0));

                const geometry = new ConvexGeometry( points );
                const material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
                const mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );
            // function drawCircle(radius, color, lineWidth){
			
            //         var points = [];
                    
            //         // 360 full circle will be drawn clockwise
            //         for(let i = 0; i <= 360; i++){
            //             points.push(Math.sin(i*(Math.PI/180))*radius, Math.cos(i*(Math.PI/180))*radius, 0);
            //         }

            //         var geometry = new LineGeometry();
            //         geometry.setPositions( points );
                
            //         var material = new LineMaterial({
            //             color: color,
            //             linewidth: lineWidth
            //         });

            //         let line = new Line2( geometry, material );
            //         //line.computeLineDistances();

            //         scene.add( line );
            //     }

            //     drawCircle(0.5, "0xFFFFFF", 0.0044);

                function render()
                {
                    setTimeout( function() {
                         requestAnimationFrame(render);
                    }, 1000 / 30 ); //Pagreita kadru atvaizdavima
                    renderer.render( scene, camera );
                }

                render();
            }
            main();
        </script>
    </body>
</html>
