<!DOCTYPE html>
<html>
    <head>
		<meta charset="utf-8">
		<title>IIIB uzd. ND</title>
		<style>
			body { margin: 0; }
		</style>
        <!-- <script src="lib/three.js"></script> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js" integrity="sha512-u+vtyZDzyd0zgAEffKfoNx2BnCahAOBBYvzGu6vma1B18zQ6lEGF3F6dAFvqaxDoIU/GZRxcXV5oq23OIrkQwg==" crossorigin="anonymous"></script>
       
    </head>
    <body>
        <canvas id="c"></canvas>
        <script type="module">
            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.module.js';
            import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
            import { ConvexGeometry } from "https://threejs.org/examples/jsm/geometries/ConvexGeometry.js";
    
            function main() {

                //For animation switching
                var goBackDolly = false;
                var goBackFollow = false;
              

                const canvas = document.querySelector('#c');
                const renderer = new THREE.WebGLRenderer({canvas});
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                //var cameras = [];
                const fov = 80;
                const aspect =  2;  // the canvas default
                const near = 0.1;
                const far = 1000;

                //Camera for navigation
                const c0 = new THREE.PerspectiveCamera(fov, aspect, near, far);
                c0.position.z = 20;
                // Creating camera
               
                //Bendro vaizdo kamera
                const c1 = new THREE.PerspectiveCamera(fov, aspect, near, far);
                c1.rotation.y = (90 * Math.PI / 180);
                c1.position.y = 5;
                c1.position.z = 10;
                c1.position.x = 45;

                //cameras.push(c1);

                const c2 = new THREE.PerspectiveCamera(fov, aspect, near, far);
                c2.rotation.y = (-137 * Math.PI / 180);
                c2.position.x = -15;
                c2.position.y = 10;
                c2.position.z = -15;                
               

                const c3 = new THREE.PerspectiveCamera(fov, aspect, near, far);
                c3.rotation.x = (-270 * Math.PI / 180);
                c3.position.x = 20;
                c3.position.y = 20;
                c3.position.z = 20;                
               

                // Setuping orbit controls
                const controls = new OrbitControls( c0, renderer.domElement );
                controls.addEventListener( 'change', render );
                
                // Adding 3D grid
                const size = 10;
                const divisions = 10;

                const gridHelper = new THREE.GridHelper( size, divisions );
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.add( gridHelper );

                //Adding 3d axes
                const axesHelper = new THREE.AxesHelper( 10 );
                scene.add( axesHelper );
                // Adding basic light
                {
                    const color = 0xFFFFFF;
                    const intensity = 2;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 5, 15);
                    scene.add(light);

                    const color1 = 0xFFFFFF;
                    const intensity1 = 2;
                    const light1 = new THREE.DirectionalLight(color1, intensity1);
                    light1.position.set(0, -5, -15);
                    scene.add(light1);
                }
            
                //Visualizing the camera
               
                const helper1 = new THREE.CameraHelper( c1 );
                scene.add( helper1 );

                const helper2 = new THREE.CameraHelper( c2 );
                scene.add( helper2 );

                const helper3 = new THREE.CameraHelper( c3 );
                scene.add( helper3 );


                //Adding the camera
                scene.add(c0);
                scene.add(c1);
                scene.add(c2);
                scene.add(c3);

                //Sachmatu lenta
                function createCheckerBoard(sizeX, sizeZ)
                {
                    const board = new THREE.Group();
                    var sideColors = [0x000000, 0xffffff];
                    var switchColor = false;
                    for (var posZ = 0; posZ < sizeZ; posZ += 5)
                    {
                        for (var posX = 0; posX < sizeX; posX += 5)
                        {
                            const geometry = new THREE.PlaneGeometry( 5, 5, 32 );
                            const material = new THREE.MeshPhongMaterial( {color: sideColors[switchColor ? 0 : 1], side: THREE.DoubleSide} );
                            const plane = new THREE.Mesh( geometry, material );
                            plane.position.x += posX;
                            plane.position.z += posZ;
                            plane.rotation.x = (90 * Math.PI / 180);

                            board.add( plane );

                            switchColor = !switchColor;
                        }
                        switchColor = !switchColor;
                    }

                    return board;
                }
                function createRikis()
                {
                    const rikis = new THREE.Group();

                    const geometry = new THREE.SphereGeometry( 1.75, 32, 32 );
                    const material = new THREE.MeshPhongMaterial( {color: 0x000000} );
                    const sphere = new THREE.Mesh( geometry, material );
                    sphere.position.y = 4;
                    rikis.add(sphere);

                    const cgeometry = new THREE.ConeGeometry( 3, 6, 30 );
                    const cmaterial = new THREE.MeshPhongMaterial( {color: 0x000000} );
                    const cone = new THREE.Mesh( cgeometry, cmaterial );
                    cone.position.y = 3;
                    rikis.add(cone);

                    const cygeometry = new THREE.CylinderGeometry( 2, 2, 3, 32 );
                    const cymaterial = new THREE.MeshPhongMaterial( {color: 0x000000} );
                    const cylinder = new THREE.Mesh( cygeometry, cymaterial );
                    rikis.add(cylinder);

                    return rikis;
                }
                
               //NOTE: Apply when certain condition is met
                
               let clock = new THREE.Clock();
               let delta = 0;
               //30 fps
               let interval = 1 / 30;               
               
                function viewScene()
                {
                    requestAnimationFrame(viewScene);
                    render(c1);
                }
                function doolyZoomAnim()
                {
                    requestAnimationFrame(doolyZoomAnim);
                    render(c2);

                    if(c2.position.x <= -30 && c2.position.z <= -30)
                    {
                        goBackDolly = true;
                            
                    }
                    if (c2.position.x >= -20 && c2.position.z >= -20)
                    {
                        goBackDolly = false; 
                    }
                     if (!goBackDolly)
                    {
                        c2.position.x -= 0.05;
                        c2.position.z -= 0.05;

                        c2.fov -= 0.15;
                        c2.updateProjectionMatrix();
                    }                    
                    if (goBackDolly)
                    {
                        c2.position.x += 0.05;
                        c2.position.z += 0.05;

                        c2.fov += 0.15;
                        c2.updateProjectionMatrix();
                    } 
                }

                const checkerBoard = createCheckerBoard(40, 40);
                scene.add(checkerBoard);

                const spawnRikis = createRikis();
                spawnRikis.position.y = 2;
                spawnRikis.position.x = 0;
                spawnRikis.position.z = 0;

                scene.add(spawnRikis);

                function cameraFollow()
                {
                    requestAnimationFrame(cameraFollow);
                    render(c3);

                    c3.lookAt(spawnRikis.position);                   
                    
                    if (spawnRikis.position.x >= 35 && spawnRikis.position.z >= 35)
                    {
                        goBackFollow = true;
                    }
                    else if (spawnRikis.position.x <= 1 && spawnRikis.position.z <= 1)
                    {
                        goBackFollow = false;
                    }

                    if (!goBackFollow)
                    {
                        spawnRikis.position.x += 0.2;
                        spawnRikis.position.z += 0.2;
                    }
                    else
                    {
                        spawnRikis.position.x -= 0.2;
                        spawnRikis.position.z -= 0.2;
                    }
                   
                }

                 //Simple UI
                var gui = new dat.GUI();

                var windowGui = gui.addFolder('III task. B part. Camera');

                var mainSceneCam = windowGui.addFolder("Main scene camera");

                mainSceneCam.add({ add:function(){
                    viewScene();
                     
                }}, "add").name("View");
                
                var dollyZoomCam = windowGui.addFolder("Dolly zoom camera");

                dollyZoomCam.add({ add:function(){
                    doolyZoomAnim();
                }}, "add").name("View");

                var followCam = windowGui.addFolder("Follow camera");
                followCam.add({ add:function(){

                    cameraFollow(spawnRikis);

                }}, "add").name("View");
                
                render(c1);

                function update(camera) {
                    requestAnimationFrame(update);
                    delta += clock.getDelta();

                    if (delta  > interval) {
                            // The draw or time dependent code are here
                            render(camera);

                            delta = delta % interval;
                        }
                }
                function render(camera)
                {
                    renderer.render( scene, camera );
                }
            }
            main();
        </script>
    </body>
</html>
