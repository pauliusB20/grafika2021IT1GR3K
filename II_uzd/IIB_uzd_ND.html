<!DOCTYPE html>
<html>
<head>
    <!-- 3 var. -->
    <!-- Add IcosahedronGeometry , BoxGeometry, TetrahedronGeometry  -->
    <title>IIB uzd. ND</title>
    <style>
        body { margin: 0; }
    </style>
    <script src="lib/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js" integrity="sha512-u+vtyZDzyd0zgAEffKfoNx2BnCahAOBBYvzGu6vma1B18zQ6lEGF3F6dAFvqaxDoIU/GZRxcXV5oq23OIrkQwg==" crossorigin="anonymous"></script>
</head>
<body>
    <canvas id="c"></canvas>
    <script type="module">
         import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
        function main()
        {
                const canvas = document.querySelector('#c');
                const renderer = new THREE.WebGLRenderer({canvas});
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                // Creating camera
                const fov = 80;
                const aspect =  2;  // the canvas default
                const near = 0.1;
                const far = 1000;
                const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
                camera.position.z = 15;

                // Setuping orbit controls
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.addEventListener( 'change', render );
                
                // Adding 3D grid
                const size = 10;
                const divisions = 10;

                const gridHelper = new THREE.GridHelper( size, divisions );
                const scene = new THREE.Scene();
                scene.add( gridHelper );

                //Adding 3d axes
                const axesHelper = new THREE.AxesHelper( 10 );
                scene.add( axesHelper );
                // Adding basic light
                {
                    const color = 0xFFFFFF;
                    const intensity = 2;
                    const light = new THREE.DirectionalLight(color, intensity);
                    light.position.set(0, 5, 15);
                    scene.add(light);

                    const color1 = 0xFFFFFF;
                    const intensity1 = 2;
                    const light1 = new THREE.DirectionalLight(color1, intensity1);
                    light1.position.set(0, -5, -15);
                    scene.add(light1);
                }
            //     //Drawing octahedron
                var geometry = new THREE.TetrahedronGeometry( 10, 0 ); // or DodecahedronGeometry
                const wireframe = new THREE.WireframeGeometry( geometry );

                const line = new THREE.LineSegments( wireframe );
                line.material.depthTest = false;
                line.material.linewidth = 0.5;
                line.material.opacity = 5;
                line.material.transparent = true;
                scene.add( line );
               
       
                function createJoint(point)
                {
                    const g = new THREE.SphereGeometry( 0.5, 32, 32 ); //r, wsubdivision, hsudivision
                    const m = new THREE.MeshPhongMaterial( {color: 0xFFFFFF} );
                    const s = new THREE.Mesh( g, m );
                    s.position.set(point.x, point.y, point.z);
                    return  s;
                }
                function createConnector(width)
                {
                    const geometry = new THREE.CylinderGeometry( 0.5, 0.5, width, 32 );
                    const material = new THREE.MeshPhongMaterial( {color: 0xffffff} );
                    const cylinder = new THREE.Mesh( geometry, material );
                    return cylinder;
                    //scene.add( cylinder );
                }
                function cylinderMesh(pointX, pointY, material) {
                    var direction = new THREE.Vector3().subVectors(pointY, pointX);
                    var orientation = new THREE.Matrix4();
                    orientation.lookAt(pointX, pointY, new THREE.Object3D().up);
                    orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                        0, 0, 1, 0,
                        0, -1, 0, 0,
                        0, 0, 0, 1));
                    var edgeGeometry = new THREE.CylinderGeometry(0.2, 0.2, direction.length(), 8, 1);
                    var edge = new THREE.Mesh(edgeGeometry, material);
                    edge.applyMatrix(orientation);
                    // position based on midpoints - there may be a better solution than this
                    edge.position.x = (pointY.x + pointX.x) / 2;
                    edge.position.y = (pointY.y + pointX.y) / 2;
                    edge.position.z = (pointY.z + pointX.z) / 2;
                    return edge;
                }
                function createTetGeo(size)
                {
                    var pivotSphere = createJoint(new THREE.Vector3( 0, 0, 0 ));
                    const points = [];
                    points.push(new THREE.Vector3( -size, size, size ));
                    points.push(new THREE.Vector3( size, size, -size ));
                    points.push(new THREE.Vector3( size, -size, size ));
                    points.push(new THREE.Vector3( -size, -size, -size ));

                    for (var i = 0; i < points.length; i++)
                        pivotSphere.add(createJoint(points[i]));  

                    pivotSphere.add(cylinderMesh(points[2], points[3], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));   
                    pivotSphere.add(cylinderMesh(points[2], points[1], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));  
                    pivotSphere.add(cylinderMesh(points[3], points[1], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));   
                    pivotSphere.add(cylinderMesh(points[2], points[0], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));  
                    pivotSphere.add(cylinderMesh(points[3], points[0], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));    
                    pivotSphere.add(cylinderMesh(points[2], points[1], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));  
                    pivotSphere.add(cylinderMesh(points[1], points[0], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));                 
                    return pivotSphere;
                }
                function createOctaTh(size)
                {
                    var pivotSphere = createJoint(new THREE.Vector3( 0, 0, 0 ));
                    const points = [];
                    points.push(new THREE.Vector3( 0, 0, -size ));
                    points.push(new THREE.Vector3( 0, 0, size));
                    points.push(new THREE.Vector3( size, 0, 0 ));
                    points.push(new THREE.Vector3( -size, 0, 0));
                    points.push(new THREE.Vector3( 0, size, 0 ));
                    points.push(new THREE.Vector3( 0, -size, 0));

                    for (var i = 0; i < points.length; i++)
                        pivotSphere.add(createJoint(points[i]));                   
                    
                    
                    pivotSphere.add(cylinderMesh(points[0], points[2], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[2], points[1], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[0], points[3], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[0], points[2], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[3], points[1], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                   
                    pivotSphere.add(cylinderMesh(points[0], points[4], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[1], points[4], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[2], points[4], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[3], points[4], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    
                    pivotSphere.add(cylinderMesh(points[0], points[5], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[1], points[5], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[2], points[5], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                    pivotSphere.add(cylinderMesh(points[3], points[5], new THREE.MeshPhongMaterial( { color: pivotSphere.material.color } )));
                  
                    return pivotSphere;
                }

                var octGeo = createOctaTh(10);
                octGeo.scale.x = 0.2;
                octGeo.scale.y = 0.2;
                octGeo.scale.z = 0.2;
                scene.add(octGeo);
                var tetGeo = createTetGeo(5); 
                tetGeo.scale.x = 0.4;
                tetGeo.scale.y = 0.4;
                tetGeo.scale.z = 0.4;           
                scene.add(tetGeo);
                
              

                function render()
                {
                    //requestAnimationFrame(render);
                    renderer.render( scene, camera );
                }
                render();
        }
        main();
    </script>
</body>

</html>